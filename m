Return-Path: <linux-pm-owner@vger.kernel.org>
X-Original-To: lists+linux-pm@lfdr.de
Delivered-To: lists+linux-pm@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 239A7585B7B
	for <lists+linux-pm@lfdr.de>; Sat, 30 Jul 2022 20:06:39 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S235170AbiG3SGi (ORCPT <rfc822;lists+linux-pm@lfdr.de>);
        Sat, 30 Jul 2022 14:06:38 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:38784 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229742AbiG3SGg (ORCPT
        <rfc822;linux-pm@vger.kernel.org>); Sat, 30 Jul 2022 14:06:36 -0400
Received: from phobos.denx.de (phobos.denx.de [85.214.62.61])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id C225715729
        for <linux-pm@vger.kernel.org>; Sat, 30 Jul 2022 11:06:34 -0700 (PDT)
Received: from tr.lan (ip-86-49-12-201.bb.vodafone.cz [86.49.12.201])
        (using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits))
        (No client certificate requested)
        (Authenticated sender: marex@denx.de)
        by phobos.denx.de (Postfix) with ESMTPSA id 23A4884070;
        Sat, 30 Jul 2022 20:06:33 +0200 (CEST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=denx.de;
        s=phobos-20191101; t=1659204393;
        bh=VVm3jt8ej/l/H6HJPP9/rYDDUrIgyFBWzyD2gMovHTg=;
        h=From:To:Cc:Subject:Date:From;
        b=a1J26kEb3lBJ6evXHoYv6YvIT6qIpg0IEHnOr4DCSxXYYmu27gOUUkBg2gDM16DVp
         T8YCzNEQHGgu9rvKAoD56lKWJ39BdLaxJCac6itZWsg+7w3DyI7VLVOEF5JMb8MLvj
         tq32IMGwYERSHvcDftAHERKsGYWladkoV5/hgSd4o6EltchDRJJSKPQRYkMZYAts+3
         e7dkcAqHtnNkl4G7t5n4Sa+ORprpIZR8hqkHwxiIQDGGzLERBqrTYB9jxoVDt+ENlf
         oBFD8a8Vi0qZoHRLwzBKG+fluW7OnytH4Mw5S6l88Fsti0p2Vpuvq9hywL4UJv/mfz
         nd/uuP7lTePyw==
From:   Marek Vasut <marex@denx.de>
To:     linux-pm@vger.kernel.org
Cc:     Marek Vasut <marex@denx.de>,
        Andy Shevchenko <andriy.shevchenko@linux.intel.com>,
        Hans de Goede <hdegoede@redhat.com>,
        Sebastian Reichel <sebastian.reichel@collabora.com>
Subject: [PATCH] power: supply: bq25890: Add support for setting IINLIM
Date:   Sat, 30 Jul 2022 20:06:30 +0200
Message-Id: <20220730180630.152098-1-marex@denx.de>
X-Mailer: git-send-email 2.35.1
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-Virus-Scanned: clamav-milter 0.103.6 at phobos.denx.de
X-Virus-Status: Clean
X-Spam-Status: No, score=-4.4 required=5.0 tests=BAYES_00,DKIM_SIGNED,
        DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_MED,SPF_HELO_NONE,
        SPF_PASS autolearn=ham autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-pm.vger.kernel.org>
X-Mailing-List: linux-pm@vger.kernel.org

Let user set input current limit via sysfs. This is useful in case there
are multiple chargers connected to the device, each of which with its own
arbitrary maximum current which it can provide, some of which may provide
more than the default 500mA. In that case, userspace can listen for plug
events generated by each charger and adjust the current limit accordingly,
e.g. to permit battery to charge faster.

Note that the IINLIM is reset every time the bq25890 is disconnected from
a charger, so the userspace must adjust the limit repeatly on every plug
event.

Signed-off-by: Marek Vasut <marex@denx.de>
---
Cc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Cc: Hans de Goede <hdegoede@redhat.com>
Cc: Sebastian Reichel <sebastian.reichel@collabora.com>
To: linux-pm@vger.kernel.org
---
 drivers/power/supply/bq25890_charger.c | 30 ++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/drivers/power/supply/bq25890_charger.c b/drivers/power/supply/bq25890_charger.c
index 131ec7d882fe9..e412bcf90b40c 100644
--- a/drivers/power/supply/bq25890_charger.c
+++ b/drivers/power/supply/bq25890_charger.c
@@ -613,6 +613,34 @@ static int bq25890_power_supply_get_property(struct power_supply *psy,
 	return 0;
 }
 
+static int bq25890_power_supply_set_property(struct power_supply *psy,
+					     enum power_supply_property psp,
+					     const union power_supply_propval *val)
+{
+	struct bq25890_device *bq = power_supply_get_drvdata(psy);
+	u32 lval;
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		lval = clamp(val->intval, 100000, 3250000);
+		lval = DIV_ROUND_UP(lval - 100000, 50000);
+		return bq25890_field_write(bq, F_IINLIM, lval);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int bq25890_power_supply_property_is_writeable(struct power_supply *psy,
+						      enum power_supply_property psp)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		return true;
+	default:
+		return false;
+	}
+}
+
 static int bq25890_get_chip_state(struct bq25890_device *bq,
 				  struct bq25890_state *state)
 {
@@ -837,6 +865,8 @@ static const struct power_supply_desc bq25890_power_supply_desc = {
 	.properties = bq25890_power_supply_props,
 	.num_properties = ARRAY_SIZE(bq25890_power_supply_props),
 	.get_property = bq25890_power_supply_get_property,
+	.set_property = bq25890_power_supply_set_property,
+	.property_is_writeable = bq25890_power_supply_property_is_writeable,
 };
 
 static int bq25890_power_supply_init(struct bq25890_device *bq)
-- 
2.35.1

